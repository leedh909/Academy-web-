2020.4.23 [수업 20일차]




*미니 프로젝트?(5/1~5/12)
//프로젝트의 맛을 살짝보는 정도이다.
//자바로 진행
//GUI 
//창을 만들어서 프로그램 만든다.
//주제: 자유~~





진행 : 미니 프로젝트 팀원회의 



------------------------------------------------------------------------------------



진행 : 스레드(Thread), 네트워크(Network)




*프로세스
//실행중인 프로그램을 의미
//하나 이상의 스레드로 구성된다.

*스레드
//실제 작업을 수행하는 작업 단위
//병렬로 실행이 가능하다.

*멀티 프로세스
//각각의 프로세스를 독립적으로 실행
//남을 의미한다.

*멀티 스레드
//하나의 프로세스 내에서 여러 스레드가 동시에 작업을 수행한다.
(장점)
//CPU 사용률 향상
//자원을 보다 효율적으로 사용 가능
//사용자의 대한 응답성 향상
//애플리케이션의 응답성 향상
//코드가 간결해짐
//cpu는 안쉬면 좋다고 본다.
(단점)
//동기화에 주의해야함 (한명이 쓰고있으면 다른애는 기다린다.)
//교착상태가 발생하지 않도록 주의해야함 (프로그램이 진행이 안되는상태, 서로 끝나지않음)
//프로그래밍 시 고려해야 할 사항이 많음



*Thread 클래스를 상속받는 방법
//스레드를 실행시키려면 .start(); 를 써야한다.

*Runnable 인터페이스 구현


*스케쥴링
//누가 언제 얼마만큼 일을 할지를 결정하는 것이다.
//스케쥴링에 의해 스레드들은 번갈아가며 run()메소드를 조금씩 실행.

(어떻게 할당해주냐)
//우선 순위 방식(Priority) - 숫자가 높을 수록 실행해준다.
//순환 할당 방식(Round-Robin) - 정해진 시간만큼 실행시키는 방식. 


스레드 컨트롤
//스레드 생성 -> (실행 대기 -> 실행 -> 일시정지 -> 실행 대기-> 실행) -> 스레드 소멸


*WAS(Web Application Server)
//WAS에 올려서 프로그램을 돌린다.
//우리 프로그램에 접근하면 WAS가 알아서 스레드를 생성해준다.
//그 스레드 위에서 돌아간다.


*동기화(Synchronized)
//다른 프로그램이 실행중일때 다른 프로그램이 간섭하지 못하도록 하는것.
//일반메소드만 동시에 사용가능하고 다른 동기화메소드와 동기화블록은 동시에 사용하지 못한다.


*데몬 스레드
//ex)가비지 컬랙터
//다른 스레드의 작업을 보조해주는 역할
//스레드 삭제시 같이 종료된다.


*Runtime 클래스를 이용한 프로그램 실행시키는 방법.
//자바 클라스가 아닌 OS기반의 프로그램을 실행 시키거나 정보를 제공하는 객체! Runtime
//ex) Runtime rt = Runtime.getRuntime();    -> 크롬창 실행시키기
 try {
	Process prc = rt.exec("\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"");
 } catch (IOException e) {
	e.printStackTrace();
 }


---------------------------------------------------------------
*네트워크(Network)
//여러 대의 컴퓨터를 연결한 것이다.

// L(ocal)AN -지역
// M(etro)AN -도시
// W(ide )AN -세계 


*서버 와 클라이언트
//클라이언트 == 요구하는 놈이다. 서비스를 받는 프로그램.
//서버 == 클라이언트가 요구하는 내용을 보여주는 놈이다. 서비스를 제공하는 프로그램.

*IP주소
//네트워크 상에서 컴퓨터를 식별하는 번호, 랜카드마다 할당되어있다.

*포트
//컴퓨터내에 프로그램을 인식하는(=식별하는) 번호이다.


*InetAddress 클래스
//IP주소를 다루기 위해 자바에서 제공하는 클래스


*소켓프로그래밍
//소켓을 이용한 통신 프로그래밍.
//소켓 : 프로세스 간의 통신에 사용되는 양쪽 끝 단.
//TCP : 속도가 느리지만 안정적이다.. 두 친구가 연결된 상태에서 원하는걸 주는것이다.(자꾸 되물어본다.(잘받았다고.)) - 연결지향적 프로토콜
//UDP : 속도가 빠르지만 신뢰성이 없다. 한번에 많은 양을 클라이언트에게 던져준다. - 비연결 지향적 프로토콜 

//요청을 하면 accept() 메소드로 수락을 한다.


*서버용 TCP 소켓 프로그래밍 순서
1. 서버의 포트번호 정함
2. 서버용 소켓 객체 생성
3. 클라이언트 쪽에서 접속 요청이 오길 기다림
4. 접속 요청이 오면 요청 수락 후 해당 클라이언트에 대한 소켓 객체 생성
5. 연결된 클라이언트와 입출력 스트림 생성
6. 보조 스트림을 통해 성능 개선
7. 스트림을 통해 읽고 쓰기
8. 통신종료


*클라이언트 TCP 소켓 프로그래밍 순서
1. 서버의 IP주소와 서버가 정한 포트번호를 매개변수로 하여 클라이언트용 소켓 객체 생성
2. 서버와의 입출력 스트림 오픈
3. 보조 스트림을 통해 성능 개선
4. 스트림을 통해 읽고 쓰기
5. 통신종료



*UDP 소켓 프로그래밍
//비연결지향적이라 연결 요청을 받아줄 서버 소켓이 필요없음
//두 개의 DatagramSocket간에 DatagramPacket으로 변환된 데이터 주고 받음

*서버용 UDP 소켓 프로그래밍 순서
1. 서버의 포트번호 정함
2. DatagramSocket 객체
3. 연결한 클라이언트 IP주소를 가진 InetAddress 객체 생성
4. 전송할 메세지를 byte[]로 바꿈
5. 전송할 메세지를 DatagramPacket 객체에 담음
6. 소켓 레퍼런스를 사용하여 메시지 전송
7. 소켓 닫음


*클라이언트용 UDP 소켓 프로그래밍 순서
1. 서버가 보낸 메세지를 받을 byte[] 준비
2. DatagramSocket 객체 생성
3. 메세지 받을 DatagramPacket객체 준비
4. byte[]로 받은 메세지를 String으로 바꾸어 출력
5. 소켓 닫음














