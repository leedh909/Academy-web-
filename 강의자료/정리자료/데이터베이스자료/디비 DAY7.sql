--MEMBER 테이블을 생성하여
--사용자 정보를 받을 수 있는 테이블 객체를 만들되,
--회원 번호는 NUMBER형태로 기본키 설정하고,
--회원 아이디는 중복 불가에 필수 입력 사항으로, 
--회원 비밀번호는 필수 입력 사항,
--회원 이름, 성별('M','F'),
--회원 연락처, 회원 생년월일 정보를
--받을 수 있는 컬럼을 가진 테이블을 생성하시오.
--단, 각 컬럼의 길이는 직접 판단하고,
--위에 생성된 테이블 기준으로 
--회원 정보를 최소 5개 이상 삽입하여 확인하시오.
CREATE TABLE MEMBER(
	MEMBER_NO NUMBER CONSTRAINTS MEMBER_MEMBER_NO PRIMARY KEY,
	MEMBER_ID VARCHAR2(20) CONSTRAINTS MEMBER_MEMBER_ID_UN UNIQUE CONSTRAINTS MEMBER_MEMBER_ID_NN NOT NULL,
	MEMBER_PWD VARCHAR2(20) CONSTRAINTS MEMBER_MEMBER_PWD NOT NULL,
	MEMBER_NAME VARCHAR2(15),
	MEMBER_GENDER CHAR(3) CONSTRAINTS MEMBER_MEMBER_GENDER CHECK(MEMBER_GENDER IN('M','F')),
	PHONE VARCHAR2(14),
	BIRTH VARCHAR2(14)
	
);
--강사님 코딩
CREATE TABLE MEMBER_1(
	M_NO NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
	M_ID VARCHAR2(15) NOT NULL UNIQUE,
	M_PWD VARCHAR2(30) NOT NULL,
	M_NAME VARCHAR2(15),
	M_GENDER CHAR(1) CHECK(M_GENDER IN ('M','F')),
	M_MAIL VARCHAR2(30),
	M_PHONE VARCHAR2(14),
	M_BIRTH DATE
);

COMMENT ON COLUMN MEMBER_1.M_NO IS '회원번호';
COMMENT ON COLUMN MEMBER_1.M_ID IS '회원아이디';


SELECT * FROM MEMBER;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'MEMBER';

INSERT INTO MEMBER VALUES(1,'USER01','PASS01','이대희','M','010-1234-1234','900101');
INSERT INTO MEMBER VALUES(2,'USER02','PASS01','이대희','M','010-1234-1234','900101');
INSERT INTO MEMBER VALUES(3,'USER03','PASS01','이대희','M','010-1234-1234','900101');
INSERT INTO MEMBER VALUES(4,'USER04','PASS01','이대희','M','010-1234-1234','900101');
INSERT INTO MEMBER VALUES(5,'USER05','PASS01','이대희','M','010-1234-1234','900101');


INSERT INTO MEMBER_1 
VALUES(1,'USER01','PASS01','이대희','M','LEE@KH.OR.KR','010-1234-1234',TO_DATE(101010,'RRMMDD'));

SELECT * FROM MEMBER_1;

--FOREIGN KEY--
--외래키, 외부키, 참조키 라고 한다.
--다른 테이블의 컬럼값을 참조(REFERENCE)하여 참조하는 테이블의 값만 허용
--FOREIGN KEY 제약조건을 통해 다른 테이블과의 관계(RELATIONSHIP)가 형성 된다.

--컬럼레벨일 경우
--컬럼명 자료형(길이) [CONSTRAINT 제약조건명] REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
--테이블 레벨 일 경우
-- [CONSTRAINT 제약조건명] FOREIGN KEY(적용할 컬럼명) REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]
--대갈호[]는 생략 가능한 부분이다.


DROP TABLE USER_GRADE;

CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK( GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;

INSERT INTO USER_FOREIGN_KEY VALUES(6,'QWE','ABC','JANG','M',10);

SELECT *
FROM USER_FOREIGN_KEY 
JOIN USER_GRADE USING(GRADE_CODE);

--삭제옵션
DELETE FROM USER_GRADE WHERE GRADE_CODE=4;

--참조하고 있는 원본 테이블의 컬럼 값이 삭제될때
--참조한 값을 어떻게 처리할 것인지 설정하는 옵션
--1. 부모 컬럼을 삭제할 때 자식을 NULL로 변경하기
-- ON DELETE SET NULL
--2. 부모 컬럼을 삭제할 때 관련된 자식도 함께 삭제하기
-- ON DELETE CASCADE

DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGN_KEY;


CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

-- 연습 1. USER_FOREIGN_KEY + ON DELETE SET NULL
CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK( GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

COMMIT;

SELECT * FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;

--이전에 COMMIT 한 시점으로 데이터가 되돌아 간다.
ROLLBACK;

SELECT * FROM USER_GRADE;

-- 연습 2. USER_FOREIGN_KEY + ON DELETE CASCADE
-- 자식 테이블의 데이터 삭제된다.

DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK( GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;

COMMIT;
DELETE FROM USER_GRADE WHERE GRADE_CODE=2;
SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;
ROLLBACK;



--트랜젝션 : 하나의 작업단위 (SELECT - INSERT - UPDATE - INSERT 순으로 작업이 이루어지는 것)
--모두 성공 혹은 모두 실패

--SUBQUERY를 활용한 테이블 생성
-- 컬럼명, 데이터 타입, 값, NOT NULL은 복사된다.
-- 하지만 다른 제약조건은 복사되지 않는다.

SELECT * FROM EMPLOYEE ;

CREATE TABLE EMPLOYEE_COPY AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE_COPY;

--테이블의 형식만 복사하기
CREATE TABLE EMPLOYEE_COPY2 AS SELECT * FROM EMPLOYEE WHERE 1=2; --데이터가 겹치지 않으니 형식만 복사되는 것이다.
SELECT * FROM EMPLOYEE_COPY2;

--각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
	DATA_COL1 VARCHAR2(30) DEFAULT '없음',
	DATA_COL2 DATE DEFAULT SYSDATE
);

INSERT INTO DEFAULT_TABLE VALUES(DEFAULT,DEFAULT);
--아무것도 입력하지 않고 기본값으로 데이터를 주기위해서는 DEFAULT로 선언해야한다.
SELECT * FROM DEFAULT_TABLE;


--제약조건을 테이블 생성 후에 추가하는 DDL
--ALTER 사용하기

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEE';

--[사용형식]
--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 ADD MODIFY 컬럼명 NOT NULL

--문제
--EMPLOYEE 테이블에서
--DEPT_CODE에 외래키 제약 조건 추가
--참조할 컬럼은 DEPARTMENT.DEPT_ID
--JOB_CODE에 외래키 제약 조건 추가
--참조할 컬럼은 JOB.JOB_CODE
--SAL_LEVEL에 외래키 제약 조건 추가
--참조할 컬럼은 SAL_GRADE.SAL_LEVEL
--ENT_YN 컬럼에 CHECK 제약조건 추가('Y','N') 대소문자 구분
--SALARY 컬럼에 CHECK 제약조건 추가( 무조건 양수 기입)
--EMP_NO 컬럼에 UNIQUE 제약 조건 추가
--DEPARTMENT 테이블에서
--LOCATION_ID 에 외래키 제약조건 추가
--LOCATION 테이블의 기본키 컬럼
--LOCATION 테이블에서 NATIONAL_CODE 외래키 제약 조건 추가
--NATIONAL 테이블의 기본키 컬럼
--
--다 만든 후에 USER_CONTRAINTS 에서 3개의 테이블 조회하기

ALTER TABLE EMPLOYEE ADD FOREIGN KEY (DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (JOB_CODE) REFERENCES JOB(JOB_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (SAL_LEVEL) REFERENCES SAL_GRADE(SAL_LEVEL);
ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);
ALTER TABLE DEPARTMENT ADD FOREIGN KEY (LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY (NATIONAL_CODE) REFERENCES NATIONAL;

SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, CONSTRAINT_TYPE,COLUMN_NAME,SEARCH_CONDITION
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME 
							AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION');



--DML(데이터 조작 언어)
--INSERT, UPDATE, DELETE, SELECT(DQL)
--[ CRUD ]
--C(CREATE) : INSERT
--R(READ)	: SELECT
--U(UPDATE) : UPDATE
--D(DELETE) : DELETE

--INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--			실행 후에는 테이블의 행의 개수가 증가

--[사용형식]
--1. 특정 컬럼에 값을 추가하는 방법
--INSERT INTO 테이블명(컬럼명, ...) VALUES(값1, ...);
--2. 모든 컬럼에 값을 추가하는 방법
--INSERT INTO 테이블명 VALUES(값, 값, ...);

SELECT * FROM EMPLOYEE ;

--컬럼명을 명시하여 데이터 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME,EMP_NO,EMAIL,PHONE,DEPT_CODE ,JOB_CODE ,SAL_LEVEL ,SALARY ,BONUS ,MANAGER_ID ,HIRE_DATE ,ENT_DATE ,ENT_YN )
VALUES(500,'추민석','700101-1234556','choo@kh.or.kr','01011112222','D1','J7','S4',3100000,0.1,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='추민석';

--컬럼을 생략하고 사용하기(모든 컬럼에 값 추가)
INSERT INTO EMPLOYEE VALUES(900,'박응서','510101-1234567','park@kh.or.kr','01022334444','D1','J7','S3',4300000,0.2,'200',SYSDATE,NULL,DEFAULT);
SELECT * FROM EMPLOYEE ;

--지금까지 변경된 내용을 실제 데이터베이스에 반영하겠다.
COMMIT;

--INSERT + SUBQUERY
--VALUES 대신 값을 지정하여 추가 가능

CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);

INSERT INTO EMP_01 (
	SELECT EMP_ID, EMP_NAME, DEPT_TITLE
	FROM EMPLOYEE 
	LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
);

SELECT * FROM EMP_01 ;

--
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE
	WHERE 1=2;

-- EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의 
-- 사번, 이름, 부서코드, 입사일을 조회하여
-- EMP_DEPT_D1 테이블에 추가
INSERT INTO EMP_DEPT_D1 (
	SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE
	WHERE DEPT_CODE='D1'
);

SELECT * FROM EMP_DEPT_D1;

COMMIT;


CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY FROM EMPLOYEE WHERE 1=2;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY FROM EMPLOYEE WHERE 1=2;

--EMPLOYEE 테이블에서
--입사일 기준 2000년 1월 1일 이전 입사자의 사번, 이름 입사일 급여를 EMP_OLD에 추가하고
--그 이후 입사자들의 사번, 이름, 입사일 급여를 EMP_NEW에 추가하여 처리하자

INSERT ALL 
	WHEN HIRE_DATE < '2000/01/01' THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
	WHEN HIRE_DATE >= '2000/01/01' THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME,HIRE_DATE, SALARY)
	SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

COMMIT;


--UPDATE : 해당 테이블의 데이터를 수정 하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 변경할 값
--[WHERE 컬럼명 비교 연산자 비교값]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT ;

SELECT * FROM DEPT_COPY ;

--D9 부서를 총무부-> 전략기회부

COMMIT;
UPDATE DEPT_COPY SET DEPT_TITLE = '전략기획부';
ROLLBACK;


UPDATE DEPT_COPY SET DEPT_TITLE ='전략기획부' WHERE DEPT_ID ='D9';
COMMIT;


--EMPLOYEE 테이블에서 사번이 200,201,214 인 사원의 주민등록번호 앞자리를 
--각각 621130, 630126, 850507로 수정해보자.
--UPDATE문 3개 작성
UPDATE EMPLOYEE SET EMP_NO = '621130'||SUBSTR(EMP_NO,7,8) WHERE EMP_ID = 200;
UPDATE EMPLOYEE SET EMP_NO = '630126'||SUBSTR(EMP_NO,7,8) WHERE EMP_ID = 201;
UPDATE EMPLOYEE SET EMP_NO = '850507'||SUBSTR(EMP_NO,7,8) WHERE EMP_ID = 214;
SELECT * FROM EMPLOYEE ;
--강사님 코드
UPDATE EMPLOYEE SET EMP_NO ='621130'||SUBSTR(EMP_NO,7) WHERE EMP_ID =200;
UPDATE EMPLOYEE SET EMP_NO ='630126'||SUBSTR(EMP_NO,7) WHERE EMP_ID =201;
UPDATE EMPLOYEE SET EMP_NO ='850507'||SUBSTR(EMP_NO,7) WHERE EMP_ID =214;


--UPDATE + SUBQUERY
--여러 행을 변경하거나, 여러 컬럼의 값을 변경하고자 할때 서브 쿼리를 사용하여 UPDATE를 작성할 수 있다.
--UPDATE 테이블 SET 컬럼명 = (서브쿼리);
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS FROM EMPLOYEE;

SELECT * FROM EMP_SALARY WHERE EMP_NAME IN('유재식','방명수');

--유재식 사원과 같은 급여와 보너스를 받고 싶어하는 방명수 사원의
--급여와 보너스를 유재식 사원과 같은 값으로 변경하는 쿼리 작성
UPDATE EMP_SALARY 
SET SALARY =(SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
	BONUS =(SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME ='유재식')	
WHERE EMP_NAME ='방명수';

--'노옹철','전형돈','정중하','하동운'의 유재식 사원과 같은 급여, 보너스로 수정
--단, 다중열 서브쿼리로 구현

UPDATE EMP_SALARY 
SET(SALARY,BONUS) = (SELECT SALARY, BONUS
						FROM EMP_SALARY 
						WHERE EMP_NAME ='유재식')
WHERE EMP_NAME IN('노옹철','정중하','전형돈','하동운');

SELECT * FROM EMP_SALARY WHERE EMP_NAME IN('유재식','방명수','노옹철','전형돈','정중하','하동운');


--UPDATE시 변경할 값이 제약조건에 위배되지 않아야 한다.
--외래키 제약조건 위배
UPDATE EMPLOYEE
SET DEPT_CODE ='D0'
WHERE DEPT_CODE ='D6';

UPDATE EMPLOYEE 
SET EMP_ID=NULL
WHERE EMP_ID =200;

SELECT * FROM EMPLOYEE e ;

UPDATE EMPLOYEE SET EMP_NO ='630126-1548654' WHERE EMP_NAME='선동일';

--UPDATE시  DEFAULT 활용--
UPDATE EMPLOYEE SET ENT_YN = DEFAULT WHERE EMP_ID =222;













